#!/usr/bin/python

import sys
import heapq


def usage():
    print 'Usage:'
    print sys.argv[0] + ' [--link-log=filename tunnel_log[ tunnel_log2 ...]'
    sys.exit(1)


def push_to_heap(heap, index, log_file, init_ts_delta_i):
    line = None

    # if log_file is mm-link-log
    if index == -1:
        # find the next delivery opportunity
        while True:
            line = log_file.readline()
            if '#' in line or not line:
                break
    else:
        # find the next arrival or departure event
        line = log_file.readline()

    if line:
        line_list = line.split(' ')
        ts = int(line_list[0]) + init_ts_delta_i
        line_list[0] = str(ts)
        if line_list[1] == '#':
            line_list[2] = '%s\n' % (int(line_list[2]) - 4)
        line = ' '.join(line_list)
        heapq.heappush(heap, (ts, index, line))

    return line


def main():
    if len(sys.argv) < 2:
        usage()

    # open log files
    link_log = None
    tun_log_begin = 1
    if sys.argv[1].startswith('--link-log'):
        if len(sys.argv) < 3:
            usage()
        link_log = open(sys.argv[1].split('=')[1])
        tun_log_begin = 2

    tun_logs = []
    for tun_log_name in sys.argv[tun_log_begin:]:
        tun_logs.append(open(tun_log_name))

    # maintain a min heap to merge sorted logs
    heap = []
    if link_log:
        # find initial timestamp in the mm-link log
        while True:
            line = link_log.readline()
            if line.startswith('# init timestamp'):
                link_init_ts = int(line.split(':')[1])
                smallest_init_ts = link_init_ts
                line = link_log.readline()
                base_ts = int(line.split(':')[1])
                break
    else:
        smallest_init_ts = sys.maxint
        base_ts = 0

    # find the smallest initial timestamp
    init_ts_delta = []
    for tun_log in tun_logs:
        line = tun_log.readline()
        init_ts = int(line.split(':')[1])
        init_ts_delta.append(init_ts)
        if init_ts < smallest_init_ts:
            smallest_init_ts = init_ts
        tun_log.readline()

    if link_log:
        link_init_ts_delta = link_init_ts - smallest_init_ts
        base_ts += link_init_ts_delta

    for i in xrange(len(init_ts_delta)):
        init_ts_delta[i] -= smallest_init_ts

    print '# init timestamp: %s' % smallest_init_ts
    print '# base timestamp: %s' % base_ts

    # build the min heap
    if link_log:
        line = push_to_heap(heap, -1, link_log, link_init_ts_delta)
        if not line:
            sys.stderr.write('No delivery opportunities found\n')
            sys.exit(1)

    for i in xrange(len(tun_logs)):
        line = push_to_heap(heap, i, tun_logs[i], init_ts_delta[i])
        if not line:
            sys.stderr.write('%s does not contain any arrival or departure'
                             ' events\n' % tun_logs[i].name)
            sys.exit(1)

    # merge all log files
    while heap:
        (ts, index, line) = heapq.heappop(heap)

        # treat each departure event as an delivery opportunity if no link log
        if not link_log and '-' in line:
            delivery_line = '%s # 1500\n' % line.split(' ', 1)[0]
            sys.stdout.write(delivery_line)

        # append flow ids to arrival and departure events
        if index != -1:
            line = line.strip() + ' ' + str(index + 1) + '\n'

        sys.stdout.write(line)

        if index == -1:
            push_to_heap(heap, index, link_log, link_init_ts_delta)
        else:
            push_to_heap(heap, index, tun_logs[index], init_ts_delta[index])

    # close log files
    if link_log:
        link_log.close()
    for tun_log in tun_logs:
        tun_log.close()


if __name__ == '__main__':
    main()
