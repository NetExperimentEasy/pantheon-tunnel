#!/usr/bin/env perl

use warnings;
use strict;

sub usage {
  die qq{Usage: $0 [filename]\n};
}

if (scalar @ARGV > 1) {
  usage;
}

sub default {
  return defined $_[0] ? $_[0] : 0;
}

my $base_timestamp = undef;

while (<>) {
  chomp;

  if (m{^# base timestamp: (\d+)}) {
    if (defined $base_timestamp) {
      die "base timestamp multiply defined";
    } else {
      $base_timestamp = $1;
    }
    last;
  }
}

if (not defined $base_timestamp) {
  die "logfile is missing base timestamp";
}

my %flows;

# 0 index of the following variables represents the total value of all flows
my (%first_ts, %last_ts);
my %data;

while (<>) {
  # parse and validate line
  my @line = split;
  my ($timestamp, $event_type, $num_bytes) = @line[0..2];

  if (not defined $num_bytes) {
    die q{Format: timestamp event_type num_bytes [delay] [flow_id]};
  }

  if ($timestamp !~ m{^\d+$}) {
    die qq{Invalid timestamp: $timestamp};
  }

  if ($num_bytes !~ m{^\d+$}) {
    die qq{Invalid byte count: $num_bytes};
  }

  $timestamp -= $base_timestamp; # correct for startup time variation

  my $num_bits = $num_bytes * 8;
  my $flow_id = 0;

  # process the event
  my @flow_tuple = (0);

  if ($event_type eq q{-}) {
    my $delay = $line[3];

    if (not defined $delay) {
      die q{Departure format: timestamp - num_bytes delay [flow_id]};
    }

    if (scalar @line == 5) {
      $flow_id = $line[4];
      if ($flow_id !~ m{^\d+$} or $flow_id <= 0) {
        die qq{Invalid flow ID: $flow_id};
      }
      $flows{$flow_id} = 1;
      push @flow_tuple, $flow_id;
    } elsif (keys %flows) {
      die q{Invalid format: Some events end with flow IDs while some not};
    }

    for my $id (@flow_tuple) {
      my %row;
      $row{ts} = $timestamp / 1000;
      $row{delay} = $delay;
      push @{$data{$id}}, \%row;
    }
  }

  for my $id (@flow_tuple) {
    if (not defined $first_ts{$id} or $timestamp < $first_ts{$id}) {
      $first_ts{$id} = $timestamp;
    }
    if (not defined $last_ts{$id} or $timestamp > $last_ts{$id}) {
      $last_ts{$id} = $timestamp;
    }
  }
}

if (scalar @{$data{0}} == 0) {
  die q{Must have at least one departure event};
}

$flows{0} = 1;
my @flow_ids = sort {$a <=> $b} keys %flows;
my %p95;

my %sorted_data;
# calculate statistics
for my $id (@flow_ids) {
  @{$sorted_data{$id}} = sort {$a->{delay} <=> $b->{delay}} @{$data{$id}};
  $p95{$id} = $sorted_data{$id}[0.95 * scalar @{$sorted_data{$id}}];

  if ($id == 0) {
    printf STDERR qq{-- Total:\n};
  } else {
    printf STDERR qq{-- Flow $id:\n};
  }

  printf STDERR qq{95th percentile per-packet one-way delay: %.0f ms\n},
         $p95{$id}{delay};
}

# make graph
open GNUPLOT, q{| gnuplot} or die;

print GNUPLOT <<END;
set xlabel "time (s)"
set ylabel "delay (ms)"
set logscale y
set key center outside top horizontal
set output "/dev/stdout"
END

print GNUPLOT qq{set terminal svg size 1024,560 fixed enhanced fname 'Arial'} .
              qq{ fsize 12 solid mouse standalone name "Delay"\n};

printf GNUPLOT qq{plot [%f:%f] }, $first_ts{0} / 1000.0, $last_ts{0} / 1000.0;

my $color = 0;
my @colors = ("#FF0000", "#00FF00", "#0000FF", "#FFFF00", "#00FFFF",
              "#FF00FF", "#C0C0C0", "#808080", "#800000", "#808000",
              "#008000", "#800080", "#008080", "#000080");

my $first_flow = 1;
for my $id (@flow_ids) {
  my $flow_str = "Flow $id per-packet";
  if (scalar @flow_ids == 1) {
    $flow_str = "Per-packet";
  } elsif ($id == 0) {
    next;
  }

  if ($first_flow) {
    $first_flow = 0;
  } else {
    print GNUPLOT qq{, };
  }

  printf GNUPLOT qq{"-" using 1:2 title "$flow_str one-way delay } .
         qq{(95th percentile %.0f ms)" with points lt 7 ps 0.2 lc rgb "%s"},
         $p95{$id}{delay}, $colors[$color];

  $color = ($color + 1) % scalar @colors;
}
print GNUPLOT "\n";

$first_flow = 1;
for my $id (@flow_ids) {
  if (scalar @flow_ids > 1 and $id == 0) {
    next;
  }

  if ($first_flow) {
    $first_flow = 0;
  } else {
    print GNUPLOT "e\n";
  }

  for my $row (@{$data{$id}}) {
    print GNUPLOT qq{$row->{ts} $row->{delay}\n};
  }
}

close GNUPLOT or die qq{$!};
